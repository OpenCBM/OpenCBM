<!doctype linuxdoc system>

<article>
<!-- $Id: opencbm.sgml,v 1.5.4.1 2007-11-11 15:09:32 strik Exp $ -->
<title>OpenCBM 0.4.1 Users Guide
<author>Michael Klein, <htmlurl url="mailto:nip@c64.org" name="nip@c64.org">,
Spiro Trikaliotis, <htmlurl url="mailto:cbm4win@trikaliotis.net"
name="cbm4win@trikaliotis.net">, Wolfgang Moser <htmlurl url="http://d81.de/" name="d81.de">
<!-- _DATE_ --><date>2007-11-11

<abstract>
This document describes the OpenCBM package, a Linux kernel module and Windows
kernel mode driver, and a few user space support programs to control and use
serial devices as used by most Commodore (CBM) 8-bit machines.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->


<sect>Overview<label id="overview">

<p>
The popular Commodore 8-bit home-computers like the C-64 and the VIC-20 are
using a custom serial bus to talk to attached devices (disk drive, printer).
The OpenCBM kernel module provides an interface to this so-called IEC bus at
the level of simple TALK and LISTEN commands, similar to the one provided by
the Commodore kernel routines. Additionally, some higher and lower level bus
control is available as well, allowing for full control of the bus. The serial
devices are connected to the PC's parallel port via an XM1541 or XA1541 cable
and, optionally, an XP1541 or XP1571 add-on cable. For cables, cf. <ref
id="cable" name="cable">.

<sect1>Introduction to OpenCBM<label id="introduction">

<p>
This is version 0.4.1 of OpenCBM, a kernel device driver for the serial CBM bus
(C64, VIC-20, etc.) for Linux and Windows. OpenCBM is a re-join of the two
projects cbm4linux (latest standalone version: 0.3.2) and cbm4win (latest
standalone version: 0.1.0a). It should be noted that both projects were highly
related from the beginning, as cbm4win 0.1.0 was based on cbm4linux 0.3.2.

Opencbm should work with any devices that understand the "normal" talk and
listen commands of the CBM IEC bus. It has been tested with several 1541,
1541-II, 1571 and 1581 drives, and a MPS-1200 pritnter. 1541 clones like the
Oceanic OC-118 have also been reported to work.

The following cable types are supported: 

<p>
<itemize>
<item>XM1541 and XA1541  (cbm4linux version >= 0.2.1, cbm4win version >= 0.1.0)
<item>XP1541             (cbm4linux version >= 0.2.0, cbm4win version >= 0.1.0)
<item>XP1571             (cbm4linux version >= 0.2.4, cbm4win version >= 0.1.0)
<item>Modified XE1541    (only on Linux, obsoleted by the XM1541, see
`LINUX/config.make')
</itemize>

More information on the different cable types can be found in <ref id="cable"
name="cable">.

This package is provided `as is', no warranty of any kind will be taken for any
damage or data loss caused by it or by any use of it.

<p>
<tt><it>*** WARNING *****************************************************</it></tt>

<tt><it>HOTPLUGGING can KILL your hardware.</it></tt>

<tt><it>Do not connect anything to the parallel port while the system or a drive is up.</it></tt>

<tt><it> Always SHUT DOWN, CONNECT, REBOOT.</it></tt>

<tt><it>Again, absolutely NO WARRANTY.</it></tt>

<tt><it>*****************************************************************</it></tt>

<sect1>Supported operating systems<label id="supported-os">

<p>
<it/OpenCBM/ supports the following operating systems:

<itemize>
<item>Linux distributions based on the Linux kernels 2.4 and 2.6;
      Kernels based on 2.0 and 2.2 might still work, but have not been tested
      for ages. For Linux, i386 and AMD64 architectures have been tested so far.
<item>Windows NT 4.0, 2000, XP, Server 2003 and Vista. The i386 architecture is fully
      supported; additionally, there are experimental AMD64 and iA64 versions
      available. Note that OpenCBM will not work on Vista 64 bit versions, as
      the driver is not signed.
</itemize>

<sect1>Supported CBM hardware<label id="supported-drives">

<p>
Currently, OpenCBM supports the following CBM devices:

<itemize>
<item>VIC 1541 (all variants, including VIC 1540 and clones)
<item>VIC 1570
<item>VIC 1571
<item>VIC 1581 (not with d64copy, not with cbmformat or cbmforng)
<item>The IEC2IEEE (<htmlurl url="http://home.arcor.de/jochen.adler/ajnhome.htm"
  name="http://home.arcor.de/jochen.adler/ajnhome.htm">) adapter
<item>other CBM IEC drives, printers, and compatibles (only with cbmctrl)
</itemize>

<sect1>Cables<label id="cable">

<p>
First of all, note that you need a parallel port cannot directly to your
system bus on your machine. That is, the parallel port should be on your
mainboard, or it should reside on a ISA card. A PCI card might work, but
we have not need much success with them, cf. <ref id="knownbugs" name="Known
Bugs">. Note also that a USB-to-parallel port connector will not work
by design!

<p>
A standard X(E)1541 cable won't work with this driver. In fact, there will
probably never be a multitasking OS which works with one of these, that's why
we call it XM1541, M for Multi­ tasking. Anyway, if you have a XE1541, the
necessary modification is simple:

<p>
 <bf>Exchange pins 5 & 6 on the Commodore DIN plug</bf>

<p>
The ACK line is the only line on a PC parallel port that can generate a
hardware interrupt. This way, we get an interrupt when the device releases the
DATA line to signal "ready to receive". Without an interrupt, you would have to
poll for this signal about every 100us, which is inacceptable for any
multitasking system.

Be sure to have your parallel port configured to use an IRQ, usually 7 or 5,
but both are often also used by soundcards.

(ASCII art taken from the StarCommander README :))

<p>
The PC parallel plug (male DB-25 connector):

<tscreen><verb>
        PaperEnd   Busy
    SelectIn   |   |   Ack        Data 7 - Data 0       Strobe
           |   |   |   |   +-------------+-------------+   |
           V   V   V   V   |                           |   V
        +------------------------------------------------------+
        | 13  12  11  10   9   8   7   6   5   4   3   2   1   |
        |  o   o   o   o   o   o   o   o   o   o   o   o   o   |
        +-+                                                  +-+
          |  o   o   o   o   o   o   o   o   o   o   o   o   |
          | 25  24  23  22  21  20  19  18  17  16  15  14   |
          +--------------------------------------------------+
             |                           |   ^   ^   ^   ^
             +-------------+-------------+   |   |   |   |
                        Ground          Select   |   |   AutoFeed
                                              Init   Error
</verb></tscreen>

<p>
The Commodore drive serial bus plug (male 6-pin DIN connector) looks like:

<tscreen><verb>
                                 Reset
                                   |
                                   V
                          +-------+ +-------+
                        +-+       +-+       +-+
                        |     5         1     |
               Data --> |     o    6    o     | <-- SrqIn
                        |          o          |
                        |     4         2     |
                Clk --> |     o    3    o     | <-- Gnd
                        |          o          |
                        +-+                 +-+
                          +-----------------+
                                   ^
                                   |
                                  Atn
</verb></tscreen>


This is the XE1541 cable (won't work with this driver):

<tscreen><verb>
    CBM drive serial port   PC parallel port

        2  Gnd ---------- 18-25  Ground
        3  Atn --------+---- 13  SelectIn
                       +->|-- 1  Strobe
        4  Clk --------+---- 12  PaperEnd
                       +->|- 14  AutoFeed
        5  Data -------+---- 11  Busy
                       +->|- 17  SelectIn
        6  Reset ------+---- 10  Ack
                       +->|- 16  Init
</verb></tscreen>


This is the XM1541 (pins 5 & 6 on the CBM end exchanged)

<tscreen><verb>
    CBM drive serial port   PC parallel port

        2  Gnd ---------- 18-25  Ground
        3  Atn --------+---- 13  SelectIn
                       +->|-- 1  Strobe
        4  Clk --------+---- 12  PaperEnd
                       +->|- 14  AutoFeed
        6  Reset ------+---- 11  Busy	
                       +->|- 17  SelectIn
        5  Data -------+---- 10  Ack
                       +->|- 16  Init
</verb></tscreen>

<p>Besides the XM1541, a XA1541 cable is also supported. That cable consists
of the same connections as the XM1541, but instead of using diodes, it uses
transistors which drive the lines better. Because of this difference, the logic
for outputs is reversed between the XA1541 and the XM1541.

<p>Additionally to the cable types above, OpenCBM also supports XP1541 and
XP1571 parallel cables, which have to be used <em>in conjunction</em> with the
XM1541 or XA1541 cable.

<p>
For more information about the different supported cables (XM1541, XA1541,
XP1541, XP1571) can be obtained on the Star Commander homepage (<htmlurl
url="http://sta.c64.org/xcables.html" name="http://sta.c64.org/xcables.html">)

<sect>News/Changelog

<p>
<descrip>
<tag/OpenCBM v0.4.1 (2007-11-11):/

<itemize>

 <item>General:
  <itemize>
  <item>@@@
  </itemize>

 <item>General, Windows specific:
  <itemize>
  <item>When doing transfers, give the kernel time to `breath' between the singled bytes (code was already there,
        but erroneous) (found by Till Harbaum for Linux)
  </itemize>

 <item>Linux driver:
  <itemize>
  <item>The build system is more robust regarding the shell used. It now specifically asks for bash.
  <item>Fixed build errors with newer Linux kernels (Spiro Trikaliotis, Frédéric Brière)
  <item>Fixed build errors with AMD64 targets (Spiro Trikaliotis, Frédéric Brière)
  <item>Implementation of cbm_setrelease() was wrong, as only only lines was modified (fixed by Till Harbaum)
  <item>When doing transfers, give the kernel time to `breath' between the singled bytes (code was already there,
        but erroneous) (fixed by Till Harbaum)
  <item>Remove all files on uninstall
  </itemize>

 <item>Windows driver:
  <itemize>
  <item>@@@
  </itemize>
</itemize>

<tag/OpenCBM v0.4.0 (2006-04-28):/

<itemize>

 <item>General:
  <itemize>
  <item>Reorganized structure so cbm4win and cbm4linux compile from the same sources
  <item>Fixed many minor and major errors
  <item>Added mnib36 (<htmlurl url="http://rittwage.com/c64pp/dp.php?pg=mnib"
  name="http://rittwage.com/c64pp/dp.php?pg=mnib">) support
  <item><it/cbmforng/: New tool, cf. <ref id="cbmforng" name="cbmforng">
  <item><it/rpm1541/: New tool, cf. <ref id="rpm1541" name="rpm1541">
  </itemize>

 <item>General, Windows specific:
  <itemize>
  <item>Use a free build instead of a checked build. This significantly reduces
  the memory footprint.
  <item>compiles for AMD64, iA64, i386 (Windows only)
  <item>VDD to allow DOS programs to access cbm4win
  <item>new unit file for Delphi, to allow to access cbm4win from Delphi
  <item>New project OpenCBMvice for debugging with the help of VICE (<htmlurl
  url="http://www.viceteam.org/" name="http://www.viceteam.org/">). For this, a
  special version of VICE is needed.
  </itemize>

 <item>Linux driver:
  <itemize>
  <item>Fixed kernel source directory (Dirk Jagdmann)
  <item>Fixed installation with GNU coreutils head (Dirk Jagdmann)
  <item>Added correct module installation dir for Linux 2.6 (Dirk Jagdmann)
  <item>Added descriptions for module parameters (<it/modinfo cbm/) (Dirk Jagdmann)
  <item>Added "smart reset" for cbm4linux: Delay the reset until all drives are ready.
  </itemize>

 <item>Windows driver:
  <itemize>
  <item>Only access the bus if the parallel port was successfully acquired.
  <item>Added ECP and EPP support into NT4 driver (allowing XP1541 cable to be used there)
  <item>On reset, do not wait a fixed timeout anymore, just wait until all drives are ready again
  </itemize>
 
 <item>instcbm:
  <itemize>
  <item><it/--lock/, <it/--cabletype/: New options
  <item><it/--automatic/ is default now, new option <it/--on-demand/ for old behaviour
  <item>Added <it/-V/ (<it/--version/) command-line option
  <item>Reworked start of driver. It was unloaded and loaded before, which does not make sense
  </itemize>

 <item>cbmctrl:
  <itemize>
  <item><it/cbmctrl popen/, <it/cbmctrl pcommand/ to do ASCII -> PETSCII conversions
  <item><it/cbmctrl status/, <it/cbmctrl dir/: Output the status on stdout, not stderr
  <item><it/cbmctrl lock/, <it/cbmctrl unlock/: New commands
  <item><it/cbmctrl read/, <it/cbmctrl write/: New commands
  <item>Added <it/--version/ and <it/--help/ command-line arguments.
  <item><it/cbmctrl change drive/: New function (heavily based on Joe Forster/STA's "TDCHANGE" from SC, used with permission)
  <item><it/cbmctrl detect/ outputs whether we have a parallel cable
  </itemize>

 <item>cbmcopy:
  <itemize>
  <item>Fixed some timing problems which resulted in hanging in rare cases;
  <item>Cosmetical fix: The device status is written on a separate line on exit.
  <item>Fixed some races between PC and drive code in the transfer functions serial1, serial2, parallel
  <item>New option <it/--transfer=auto/, which is default and finds out the best transfer method for the current setup.
  <item>Do not use $14 in the floppy drive as temporary variable, but $86. This fixes a problem with Rex-DOS.
  <item>Do not trash the file on the PC side if aborted with Ctrl+C.
  </itemize>

 <item>d64copy:
  <itemize>
  <item>Fixed some timing problems which resulted in hanging in rare cases;
  <item><it/--warp/ is default now; New option <it/--no-warp/ for disabling it.
  <item>did not recognize .d71 files as valid images; fixed that.
  <item>Fixed some races between PC and drive code in the transfer functions <it/serial1/, <it/serial2/, <it/parallel/
  <item>New option <it/--transfer=auto/, which is default and finds out the best transfer method for the current setup.
  <item>Do not use $14 in the floppy drive as temporary variable, but $86. This fixes a problem with Rex-DOS.
  <item>Do not trash the file on the PC side if aborted with Ctrl+C.
  </itemize>

 <item>API:
  <itemize>
  <item><tt/cbm_detect_xp1541()/: New function
  <item><tt/cbm_iec_setrelease()/: New function
  <item><tt/cbm_iec_set()/, <tt/cbm_iec_release()/: Extended API to allow setting/resetting more than one line at the same time
  </itemize>

 <item>Build process (Windows):
  <itemize>
  <item>reworked build process (<it/DDKBUILD_START.BAT/)
  <item><it/DDKBUILD_LOCAL.BAT/ contains settings for the CC65 build process, now.
  <item><it/ddkbuild_local.bat.sample/ added as sample for a DDKBUILD_LOCAL.BAT file
  <item><it/postbuild_local.bat.sample/ added as sample for a POSTBUILD_LOCAL.BAT file
  </itemize>

 <item>Build process (Linux):
  <itemize>
  <item>Moved makefiles into LINUX directory; thus, use <it>make -f LINUX/Makefile</it> to compile now.
  </itemize>

</itemize>

<tag/cbm4linux 0.3.3 (NEVER RELEASED!)/
<itemize>
 <item>documentation in <it/--help/ for <it/d64copy/ and <it/cbmcopy/ fixed:
  now, it is clearly stated that a XP cable must be used in combination with a
  serial cable, not as only one. (Spiro Trikaliotis)
 <item>fixed crash with unkown long options in d64copy, cbmformat and maybe cbmcopy
  (Spiro Trikaliotis)
 <item><it/cbmctrl upload/ accepts <it/-/ as filename now (read from stdin)
 <item><it/cbmctrl download/ takes optionally a file name argument (Spiro Trikaliotis)
 <item><it/libd64copy/ failed to recognize .d71 images as valid images. Because of this,
  you could not write a .d71 image back to a real floppy drive
 <item><it/d64copy/: If you copy a disc to an image which already exists, the error
  information was not removed from the file if necessary. This is fixed now.
  (Spiro Trikaliotis)
 <item><it/libd64copy/: Fixed a crash on exit of d64copy if a .d64 file grows.
 <item><tt/parport_enumerate()/-fix for kernels>=2.6.4
 <item>new ioctl <tt/CBMCTRL_CLEAR_EOI/ and API <tt/function cbm_clear_eoi()/ (Robert Norris)
 <item>minor (still compatible) API changes (Spiro Trikaliotis)
 <item><it/cbmformat/: make sure disk name is 0-terminated (Spiro Trikaliotis)
</itemize>

</descrip>

<sect>Installation<label id="installation">

<p>
Depending on the system you are running OpenCBM on, there are different ways to
install OpenCBM. Use the appropriate category for you:

<sect1>Installing OpenCBM on Linux (cbm4linux)<label id="cbm4linux-install">

<p>
The kernel module (cbm.o) does not require any kernel patches and should
compile right out of the box, at least with kernel 2.2.x, 2.4.x and 2.6.x, but 2.0.x
might still work as well.

If you intend to modify the drive routines for `d64copy' and `cbmformat' you
also need a crossassembler. `LINUX/config.make' comes with rules for A.Fachat's
`xa' (available from <htmlurl url="http://www.floodgap.com/retrotech/xa/"
name="http://www.floodgap.com/retrotech/xa/"> or <htmlurl
url="http://www.lb.shuttle.de/puffin/cbm4linux/"
name="http://www.lb.shuttle.de/puffin/cbm4linux/">; Note: xa has not been tested
lately, and might not work anymore) and Ullrich von Bassewitz' `cl65' (comes
with cc65, <htmlurl url="http://www.cc65.org/" name="http://www.cc65.org/">).
Starting with version cbm4linux 0.2.3, OpenCBM includes precompiled 6502
binaries, so as long as you don't touch the .a65 files, there's no need for a
crossassembler.

This package comes with a .spec file for those who want to build binary .RPMs.
See the RPM documentation (outside of this paper) for details about the build
process. Additionally, all files needed to built Debian .DEB packages are
included. If you upgrade from a previous (non-RPM and non-DEB) version and want
to install a packetized binary version (RPM or DEB), don't forget to remove the
old files hanging aroung (just do "<it/make uninstall/", preferably in the
*old* source directory. For a >= 0.4.0 version of OpenCBM, change the line to
"<it>make -f LINUX/Makefile uninstall</it>".).

<sect2>Compile-time configuration
<p>
The compile-time configuration is located in `LINUX/config.make'. Check the
KERN_FLAGS line if you're running kernel 2.0.x or if you don't want to use the
Linux parport subsystem for some reason. Same goes for SMP machines.


<sect2>Compilation

<p>
Type

<itemize>
<item><it>make -f LINUX/Makefile</it>    (no root privileges required)

to  build  the  kernel module, libraries and utility programs (no
root privileges required),

<item><it>make -f LINUX/Makefile dev</it>    (as root; only needed if you do not use UDEV (<htmlurl url="http://en.wikipedia.org/wiki/Udev" name="http://en.wikipedia.org/wiki/Udev">)

to   create   the  character  device "/dev/cbm" with major 10 and
minor 177 (this number is registered,  so  it  shouldn't  collide
with anything else :)). Finally

<item><it>make -f LINUX/Makefile install</it>     (as root)

will  install  all  necessary  stuff  to  /usr/local/...  (can be
changed in `LINUX/config.make')
</itemize>

<sect2>Loading the module

<p>
If  you're  using  the  parport subsystem (which is default), you
should now be able to load the driver module by issuing (as root)

<p>
<itemize>
<item><it>/sbin/depmod</it>
<item><it>/sbin/modprobe parport</it>      (unless parport is compiled into the kernel, or already loaded)
<item><it>/sbin/modprobe cbm lp=</it>your_lp   (usually 0, which is default); if you only have one parallel port, you can also use <it>/sbin/modprobe cbm</it> instead)
</itemize>

<p>
or, when built with -DDIRECT_PORT_ACCESS:

<p>
<itemize>
<item><it>/sbin/modprobe cbm port=your_ioport irq=your_irq</it>
(default is 0x378 for port, 7 for irq)
</itemize>

Check <tt>/var/log/messages</tt> if the correct cable type was recognized
(XA1541/XM1541).


<sect2>Troubleshooting

<p>
Finding the cause of a failure condition can be hard. Anyway, the
following tips might help you:

<itemize>
<item>Check <tt>/var/log/messages</tt>; it might give you some hints.

<item>If you are using the parport subsystem (no -DDIRECT_PORT_ACCESS):

<itemize>
<item>the port might be occupied by another device (e.g. `lp.o')
     cbm.o does NOT support port sharing (wouldn't work anyway).
     Enter <it>cat /proc/parport/port/devices</it> to find out.

<item>parport_pc might not use an IRQ.
     <it>/etc/modules.conf</it> should contain something like:
     <tscreen><verb>
       alias parport_lowlevel parport_pc
       options parport_pc io=0x378 irq=7
     </verb></tscreen>
     Check the interrupts with <it>cat /proc/interrupts</it>.
</itemize>

<item>Using direct port access (with -DDIRECT_PORT_ACCESS):

<itemize>
<item>The port/IRQ might occupied by another driver (e.g. parport.o)
     Enter <it>cat /proc/interrupts</it> and <it>cat /proc/ioports</it> to find
     out.
</itemize>
</itemize>


<sect2>Device access

<p>
As a first test, try something simple like

<itemize>
<item><it/cbmctrl command 8 I0:/    (assuming drive 8)
<item><it/cbmctrl status 8/
</itemize>

<p>
(no root privileges required)

<p>
Failure can be caused by:
<itemize>
<item>Possibly, the shared library in <tt>/usr/local/lib/</tt> cannot be found;
in this case, add <tt>/usr/local/lib/</tt> to <tt>/etc/ld.so.conf</tt> and
execute <it/ldconfig/ (as root)
<item>You might not have the necessary rights to the <tt>/dev/cbm</tt> device;
try <it>chmod 777 /dev/cbm</it>
<item>incorrect module parameters
<item>wrong BIOS settings (esp. IRQ)
<item>broken cable
</itemize>

<sect2>Runtime configuration

<p>
Most probably, you will want to add this to <tt>/etc/modules.conf</tt> to have
the driver loaded on demand: (the file is called <tt>/etc/conf.modules</tt> on
some older SuSE systems)

<tscreen><verb>
    alias char-major-10-177 cbm
    options cbm [options]
</verb></tscreen>

With [options] being one or more of:

<itemize>
<item><it/lp=*lp*/       (parport only, as used in <it>/sbin/modprobe</it> above)
<item><it/irq=*irq*/     (direct port only, as used in <it>/sbin/modprobe</it> above)
<item><it/port=*port*/   (direct port only, as used in <it>/sbin/modprobe</it> above)
<item><it/cable=*n*/      force cable type:
 <itemize>
 <item>               -1  for autodetection (default)
 <item>                0  for XM1541 (non-inverting)
 <item>                1  for XA1541 (inverting)
 </itemize>
<item><it/reset=*n*/     initializing behaviour:
 <itemize>
 <item>               -1  smart IEC reset (direct port default);
                          only change the status of the reset line if it was set on start
 <item>                0  no IEC reset on driver start
 <item>                1  force IEC reset (parport default);
                          always reset the device on driver start
 </itemize>
</itemize>

<sect2>Security considerations

<p>
By default, OpenCBM installs the device driver so that anyone has access to
the CBM devices:

<tscreen><verb>
    $ ls -l /dev/cbm
    crw-rw-rw- 1 root root 10, 177 2007-11-11 14:34 /dev/cbm
</verb></tscreen>

You might want to change this behaviour to control more specifically who is
allowed to use OpenCBM, and who is not.

The best way is to define a group (for example, `cbmuser') and restrict the
access rights to the owner (root) and this group (cbmuser) only.

I assume you already have defined a group `cbmuser', for example, by using
groupadd(8) (all Linux variants) or addgroup(8) (all Debian based Linux
distributions).

Now, you can restrict the access by two different means, depending upon if you
are using devfs or udev:
<itemize>
<item>If you are using devfs (all Linux kernels prior to
 2.6.0), this can be done by issuing the commands

 <tscreen><verb>
    $ chmod 660 /dev/cbm
    $ chgrp cbmuser /dev/cbm
    $ ls -l /dev/cbm
    crw-rw---- 1 root cbmuser 10, 177 2007-11-11 14:34 /dev/cbm
 </verb></tscreen>
<item>If you are using udev (newer 2.6.x kernels) instead, you have to modify
 the file /etc/udev/rules.d/45-opencbm-parallel.rules. It looks like follows:
 <tscreen><verb>
ACTION!="add", GOTO="opencbm_plugin_xa1541_rules_end"

# xa1541/xm1541 parallel port driver
KERNEL=="cbm", GROUP="root", MODE="0666"

LABEL="opencbm_plugin_xa1541_rules_end"
 </verb></tscreen>

To change the group to another one, change the part `root' in `GROUP="root"' 
by the name of the group you want to use. To change the access mode,
change `MODE="0666"' to `MODE="0660"', so your files looks like:
 <tscreen><verb>
ACTION!="add", GOTO="opencbm_plugin_xa1541_rules_end"

# xa1541/xm1541 parallel port driver
KERNEL=="cbm", GROUP="cbmuser", MODE="0660"

LABEL="opencbm_plugin_xa1541_rules_end"
 </verb></tscreen>

 For your changes to take effect, issue
 <tscreen><verb>
 $ rmmod cbm
 $ modprobe cbm
 </verb></tscreen>
 You might also want to adjust the file `sys/linux/45-opencbm-parallel.rules', which
 is used when installing the OpenCBM driver out of the source package.
</itemize>

<p>
Congratulation, you have successfully set up your OpenCBM installation!


<sect1>Installing OpenCBM on Windows (cbm4win)<label id="cbm4win-install">

<p>
<it/WARNING! If you have already installed a previous version of CBM4WIN on your
machine, you have to uninstall it before installing a new version. For this, go
to the directory where the old version is located, and enter instcbm
--remove./

First of all, Windows must know about the driver. For this, we must install it
with the instcbm tool. This is done as follows:

<itemize>
<item>Make sure you have a supported operating system up and running.

<item>You need administrator privileges on the Windows machine to perform the
following actions.

<item>At first, you have to make sure you have the needed hardware ready. Do the
following:

<itemize>
<item>Get your supported drive <ref id="supported-drives">.

<item>Moving cables with equipment turned on can damage either your PC,
and/or the drive, so, be carefull!

<item>Thus, switch off your PC and your VIC 15xx drive!

<item>Connect your XA1541 or XM1541 cable to your PC. If you have a parallel
port cable (XP1541), connect that one, too.

<item>Connect your VIC 15xx floppy drive to the cable

<item>Switch on the PC.
</itemize>

<item>Just download the binary package, and unpack it into an arbitrary
directory.

<item>Get a command-line (Start/Run, and type "<it/cmd.exe/"), change into the
directory you unpackaged the drivers into (with "<it/cd/").

<item>Type "<it/cd exe/"

<item>Type "<it/instcbm/" and check the outputs. Its last line should look like
<it/No problems found in current configuration/. In this case, you are done. In
some rare cases, <it/instcbm/ will suggest a reboot, which you should follow.

<item>You might want to have a look at the possible options for instcbm. They
are available by typing "<it/instcbm --help/". Also, cf. <ref id="instcbm"
name="instcbm">.

<item>If you had to reboot in the previous step, do the following:

<itemize><item>Go to a command-line, and change into the directory you
unpackaged the drivers into again.

<item>Type "<it/cd exe/"

<item>Type "<it/instcbm --check/". There should not be any further suggestion
for a reboot. If there is, do not proceed, but contact me instead.
</itemize>

<item>If you want to use another port than LPT1, you must tell this to the
driver. I assume you want to use LPTX, with X being the correct value, then
type: "<it/instcbm --lpt=X --update/"
</itemize>

<sect>Checking if the installation is complete
<p>
After you installed OpenCBM (cf. <ref id="installation" name="Installation">,
it is wise to check if the installation works as expected. For this, do the
following:

<itemize>
<item>Switch on the floppy drive. Depending on the type of
cable you are using (XA1541 or XM1541) and the parallel port of your PC, the
drive might keep spinning endless now, because it is continuously resetted.

<item>Type "<it/cbmctrl reset/" and press enter. If it does not already, the red
floppy drive LED should light up, and the drive should start spinning. After
approximately one second (up to five seconds in the case of a 1581), the red
LED should switch off again, and the drive stops spinning.

<item>Now, type "<it/cbmctrl status 8/" to get the status (error) code from the
attached floppy drive. If everything works fine, your drive should answer with
its identification string. For a 1541, this is something like <it/73,cbm dos v2.6
1541,00,00/, while for a 1571, this line looks like <it/73,cbm dos v3.0
1571,00,00/.
There might also be some variant of this line, depending on the firmware version
of your drive.

<item>Type "<it/cbmctrl status 8/" to get the status (error) code from the floppy
drive again. As the power on message has been read, your drive should answer with a
<it/00, ok,00,00/ string.

<item>Type "<it/cbmctrl detect/". This command tries to detect the types of drive
which are connected on the cable. You should see the drive which you posess.

<item>Now, we want to check if we can send anything to the floppy drive. Remove
any diskette from the drive and press "<it/cbmctrl open 8 15 I0/". (Make sure the "I"
is an upper-case "I". A lower-case "I" will not work!) This command tries to
initialize the disk. Anyway, since there isn't a disk in the drive, an error
occurs. You should hear the floppy spinning, and in case of a 1541, the R/W-head
should start bumping. After some seconds, the red LED starts starts flashing,
indicating that an error occurred.

<item>Now, try again "<it/cbmctrl status 8/" to get the status (error) code from
the floppy drive. As an error occurred before, an error string should be
displayed. For my setup, it is the "<it/21,read error,18,00/" string. Furthermore,
the red LED should stop flashing.
</itemize>

If you have come so far, you are sure that you send commands to the floppy, and
receive answers from it. This is very good so far. Furthermore, don't panic:
you do not have to enter these commands over and over again, these are only
tests to make sure that anything is correctly installed.

Now, let's proceed. If you have a D64 file or a floppy disc ready, you can try
transferring it over the cable. Do not use all of the following commands, but
only the ones you want to perform.

<itemize>
<item>If you want to transfer an existing floppy from the drive to the PC, use
the following command: "<it/d64copy 8 A.D64/", while replacing A.D64 by the
name you want to give to the file.

<item><bf>WARNING THE FOLLOWING COMMAND OVERWRITES ANYTHING THAT WAS ON THE FLOPPY
BEFORE, so make sure you do not need that floppy anymore.</bf>

If you have a D64 or D71 on your PC, and you want to write it to a new, already
formatted disc, enter "<it/d64copy A.D64 8/" if the file is called A.D64.

<item><bf>WARNING THE FOLLOWING COMMAND OVERWRITES ANYTHING THAT WAS ON THE FLOPPY
BEFORE, so make sure you do not need that floppy anymore.</bf>

If you have a disc you want to format, you have two options: Either use the
command "<it/cbmctrl command 8 N0:NAME,ID/", or use the cbmformat program, cf.
<ref id="cbmformat" name="cbmformat">, or the cbmforng program, cf. <ref
id="cbmforng" name="cbmforng">.
</itemize>

<p>
If you want to completely remove the cbm4win driver from your machine, you can
do so by issuing a "<it/instcbm --remove/" command.

You can have a look at the available cbmctrl commands by issuing cbmctrl on
your command line, or look at <ref id="cbmctrl" name="cbmctrl">. For the other
programs, you get help by issuing the "--help" option, or look at the
appropriate section in <ref id="utilities" name="utilities">.

<sect>Utilities<label id="utilities">

<p>
As the kernel driver is quite useless for itself, the following utility
programs are included with this package:

<itemize>
<item><it/cbmctrl/

 command line utility for direct device access at talk/listen level.

<item><it/cbmformat/

 fast 1541 disk formatter (for 1541, 1570 and 1571 drives).

<item><it/cbmforng/

 fast 1541 disk formatter (for 1541, 1570 and 1571 drives).

<item><it/d64copy/

 copies .d64 images to 1541 compatible drives and vice versa. Type `d64copy -h'
 to get a list of valid options. Use the device number to address the disk
 drive, e.g. `d64copy -t serial2 8 img.d64'.

 This version contains the StarCommander Turbo and Warp routines and custom
 transfer routines as well as parallel cable (XP1541) support. These are the
 benchmarks for Michael Klein's old Pentium-200/MMX system (seconds)

 <tscreen><verb>
 mode               write     read

 parallel turbo     54.02    53.30
 parallel warp      32.47    29.56
 serial1 turbo     168.59   168.58
 serial1 warp      183.57   158.87
 serial2 turbo      95.02    95.26
 serial2 warp       88.29    80.57
 </verb></tscreen>

<item><it/cbmcopy/

 fast 1541/1570/1571/1581 file copier.

<item><it/rpm1541/ demo

 determines the drive rotation speed of 1541, 1570 and 1571 drives.

<item><it/flash/ demo

 flashes the LED of 1541, 1570 and 1571 drives.

<item><it/morse/ demo

 morses arbitrary texts with the help of the LED of 1541, 1570 and 1571 drives.

</itemize>

<sect1>instcbm (Windows only)<label id="instcbm">
<p>
<it/instcbm/ is used on Windows to install the OpenCBM driver.

<sect2>instcbm invocation<label id="instcbm command structure">
<p>Synopsis: <tt>instcbm <it>[options]</it></tt>

<descrip>
<tag/-h, --help/
display help and exit.

<tag/-V, --version/
display version information about cbm4win.

<tag/-r, --remove/
remove (uninstall) the driver.

<tag/-e, --enumpport/
re-enumerate the parallel port driver.

<tag/-u, --update/
update parameters if driver is already installed. 

<tag/-l, --lpt=*no*/
set default LPT port to number <it/*no*/. For example, for LPT2, use <it/--lpt=2/.

If not specified, or <it/--lpt=0/ is specified, use the first parallel port.

<tag/-t, --cabletype=*TYPE*/
set cabletype to <it/*TYPE*/, which can be <it/auto/, <it/xa1541/ or <it/xm1541/.

If not specified, <it/--cabletype=auto/ is assumed.

<tag/-L, --lock=*WHAT*/
automatically lock the driver. <it/*WHAT*/ can be <it/yes/ (automatically lock)
or <it/no/ (do not automatically lock).

If not specified, <it/--lock=yes/ is assumed.

<tag/-n, --nocopy/
do not copy the driver files into the system directory. This is not recommended.

<tag/-c, --check/
only check if the installation is ok. Do not install or uninstall anything.

<tag/-F, --forcent4/
force the NT4 driver on a Win 2000, XP, or newer systems (NOT RECOMMENDED!).
This option is only available on i386 architectures; AMD64 and iA64 do not support it.

<tag/-A, --automatic/
(default) automatically start the driver on system boot.a

The driver can be used from a normal user, no need for administrator rights.
The opposite of <it/--on-demand/.

<tag/-O, --on-demand/
start the driver only on demand.

The opposite of <it/--automatic/.

</descrip>

<sect2>instcbm Examples<label id="instcbm examples">

<p>
Install the driver and the DLL on the machine. The driver and the DLL
are copied into the Windows system directory, so OpenCBM can be used from
every program:
<code>
instcbm
</code>

<p>
Install the driver, like above. Additionally, specify that you
are using an XM1541 cable:
<code>
instcbm --cabletype=xm1541
</code>

<p>
Check if the installation was set up successfully:
<code>
instcbm --check
</code>

<p>
Remove the driver from the system. You will not be able to use OpenCBM
after this command, unless you re-install it. If files were copied into
the Windows system directory, they will be removed:
<code>
instcbm --remove
</code>

<p>
After OpenCBM has been installed (with <it/instcbm/>), change the parallel
port to be used to 2:
<code>
instcbm --lpt=2 --update
</code>

<p>
Install OpenCBM, directly specifying LPT3 as the parallel port to use:
<code>
instcbm --lpt=3
</code>

<p>
Install the DLL and the driver on the machine. Do not copy the files to the
Windows system directory, but leave them "where they are". If you use this
option, the directory where your files resides must be accessible for the
system while booting. For example, network drives, USB drives or FireWire
drives are not allowed.
<code>
instcbm --nocopy
</code>

<sect1>cbmctrl<label id="cbmctrl">

<p><it>cbmctrl</it> is used to send commands to external devices. It can
control all kinds of serial CBM devices like floppy drives and printers. So
far, it has been successfully tested with the disk drives 1541(-II), 1571
and a MPS-1200 printer.

<sect2>Command structure<label id="cbmctrl command structure">
<p>The overall format of all <it>cbmctrl</it> actions is:

<p>Synopsis: <tt>cbmctrl <it>[global_options] </it>ACTION <it>[action_args]</it></tt>
<descrip>
<tag>global_options</tag>
<p>Some options that are related to <it>cbmctrl</it> in general of which affect
the oervall behaviour of all actions
<tag>action</tag>
<p>One of a bunch of different subcommands that direct <it>cbmctrl</it> what to do
<tag>action_args</tag>
<p>Arguments that are required for the subcommand <it>action</it> to work
</descrip>

<sect3>Global options<label id="cbmctrl global options">
<p><it>cbmctrl</it> understands the following global options

<descrip>
<tag>-h <it>[ACTION]</it>, --help <it>[ACTION]</it></tag>
<p>Outputs the help screen with a short listing of all available actions. If
the optional <it>ACTION</it> name is given also, you retrieve more information
on a special action together with its arguments and parameters
<tag>-V, --version</tag>
<p>Output version information as well as the built date and time
</descrip>

<sect3>Actions overview<label id="cbmctrl actions overview">
<p><it>cbmctrl</it> understands the following subcommand actions
<descrip>
<tag>reset</tag>
<p>Reset all drives on the IEC bus
<tag>detect</tag>
<p>Detect all drives on the IEC bus
<tag>lock</tag>
<p>Lock the parallel port for OpenCBM (cbm4linux/cbm4win) use
<tag>unlock</tag>
<p>Unlock the parallel port from exclusive usage
<tag>listen</tag>
<p>Perform a listen on the IEC bus
<tag>talk</tag>
<p>Perform a talk on the IEC bus
<tag>unlisten</tag>
<p>Perform an unlisten on the IEC bus
<tag>untalk</tag>
<p>Perform an untalk on the IEC bus
<tag>open</tag>
<p>Perform an open on the IEC bus
<tag>close</tag>
<p>Perform a close on the IEC bus
<tag>popen</tag>
<p>Same as open, but with ASCII to PETSCII conversion
<tag>read</tag>
<p>Get a stream of raw data from an IEC bus device
<tag>write</tag>
<p>Put a stream of raw data to an IEC bus device
<tag>status</tag>
<p>Give the status of a specified drive
<tag>command</tag>
<p>Issue a command to a specified drive
<tag>pcommand</tag>
<p>Same as command, with ASCII to PETSCII conversion
<tag>dir</tag>
<p>Output the directory of a disk in a specified drive
<tag>download</tag>
<p>Download memory contents from a floppy drive
<tag>upload</tag>
<p>Upload memory contents to a floppy drive
<tag>change</tag>
<p>Wait for a disk to be changed in a specified drive
</descrip>

<sect3>Common action arguments<label id="cbmctrl common action arguments">
<p>Many of the <it>cbmctrl</it> subcommands understand the following common
arguments:
<descrip>
<tag>[DEVICE]</tag>
<p>Advice <it>cbmctrl</it> to direct its communication to the IEC bus device
with the number <it>[DEVICE]</it>. IEC bus device numbers can be denoted in
the range from 0 to 30, although no Commodore device is known to use device
numbers 0 to 3. Most commonly used are the numbers 4 (printer) and 8 to 11
(disk drives). Device number 31 is used to denote the UNTALK respectively the
UNLISTEN command code on the IEC bus instead of the TALK respectively LISTEN
command code, therefore device address 31 cannot be used in general.
<tag>[SECADR]</tag>
<p>With several <it>cbmctrl</it> actions the secondary address parameter
<it>[SECADR]</it> denotes a dedicated logical communication channel for the
specifed <it>[DEVICE]</it> . IEC bus channel numbers can be denoted in the
range from 0 to 15. Take note that for floppy disk drive devices some
secondary addresses are interpreted in a special way. Secondary address 0 is
used, when a program is loaded, address 1, when a program is saved. Address
number 15 represents the command channel of the disk drive, so e®ectively,
for bulk data transfers to and from disk drives, only the logical channel
numbers 2 to 14 can be used.
</descrip>

<sect2>Actions<label id="cbmctrl actions">
<p><it>cbmctrl</it> understands the following actions:

<descrip>
<label id="action-reset">
<tag>reset</tag>
This action performs a hardware reset of all devices attached to the IEC bus.
Control is returned after it is made sure that all devices are ready.

<label id="action-detect">
<tag>detect</tag>
This action tries to detect all devices attached to the IEC bus.
For this, this subcommand accesses all possible devices and tries to
read some bytes from its memory. If a devices is detected, its name
is output. Additionally, this routine determines if the device is
connected via a parallel cable (XP1541 companion cable, may be true
for disk drives only).

<label id="action-lock">
<tag>lock</tag>
This command locks the parallel port for the use by OpenCBM, so that
sequences of e.g. <it/talk//<it/read//<it/untalk or <it/listen//<it/write//<it/unlisten/
are not broken by concurrent processes wanting to access the parallel port.

You should issue <it/cbmctrl lock/ before doing any access to OpenCBM tools,
and <it/cbmctrl unlock/ after you are done.

<label id="action-unlock">
<tag>unlock</tag>
This command unlocks the parallel port after the use by OpenCBM.

You should issue <it/cbmctrl lock/ before doing any access to OpenCBM tools,
and <it/cbmctrl unlock/ after you are done.

<label id="action-listen">
<tag>listen <it/device secadr/</tag>
Tell device <it>device</it> to listen on secondary address
<it/secadr/. Until the next <it/unlisten/ command,
everything output with <it>cbmctrl write</it> will be
received by this device.<p>

This command corresponds to the following 6502 assembly code on a C64:
<code>
lda #device
jsr $ffb1
lda #secadr
ora #$60
jsr $ff93
</code>

<label id="action-talk">
<tag>talk <it/device secadr/</tag>
Tell device <it/device/ to talk on secondary address <it/secadr/. Until
the next <it/untalk/ command, data from this device can be received device by
using the command <it>cbmctrl read</it>.<p>

This command corresponds to the following 6502 assembly code on a C64:
<code>
lda #device
jsr $ffb4
lda #secadr
ora #$60
jsr $ff96
</code>

<label id="action-unlisten">
<tag>unlisten</tag>
Ends communication with listening devices after a <it/listen/ command. This
corresponds to the C64 kernel routine $ffae.

<label id="action-untalk">
<tag>untalk</tag>
Ends communication with talking devices after a <it/talk/ command. This
corresponds to the C64 kernel routine $ffab.

<label id="action-open">
<tag>open <it/device secadr filename/</tag>
Open file <it/filename/ on device <it/device/. After opening, data can be
read/written by sending a <it/talk/ resp. <it/listen/ command with the
secondary address <it/secadr/.

If <it/secadr/ is greater than 1, the file type and access mode must also be
specified by appending <tt/,type,mode/ to <it/filename/. Valid types are
D, P, S, U, R (DEL, PRG, SEQ, USR, REL), valid modes are R for reading and W
for writing.

Note: You cannot do an open without a filename. Although a CBM machine (i.e., a
C64) allows this, this is an internal operation for the Computer only. It does
not have any effect on the IEC bus.

<it/cbmctrl open/ does not change any character encoding, that is, it does not
convert between ASCII (used by the PC) and PETSCII (used by the CBM device). If
this is needed, use <it/cbmctrl popen/ instead.

<label id="popen">
<tag>popen <it/device secadr filename/</tag>
Like <it/cbmctrl open/, but converts the filename from ASCII to PetSCII before
sending it to the floppy.

<label id="action-close">
<tag>close <it/device secadr/</tag>
Close the file associated with secondary address <it/secadr/ on device
<it/device/.

<label id="action-read">
<tag>read <it/[file]/</tag>
This command reads raw data from the IEC bus and outputs it into the given
file, or to stdout if no file is given (or if it is a simple dash, "-").

<label id="action-write">
<tag>write <it/[file]/</tag>
This command writes raw data to the IEC bus; the data is taken from the given
file, or from stdin if no filename is given (or if it is a simple dash, "-").


<label id="action-status">
<tag>status <it/device/</tag>
Copies input from device <it/device/, secondary address 15 (command/status
channel), to the standard output stream. Note that all upper case characters
are changed to lower case. Carriage return (0x0d) is also changed to the
current operating system's line ending convention (0x0a on Unix oriented
systems, 0x0d 0x0a on Windows oriented systems or whatever else is appropriate
for your operating system).

Assuming the device number is 8, this command is similar to (in this case, no
character conversions would be made)
<code>
cbmctrl lock
cbmctrl talk 8 15
cbmctrl read
cbmctrl untalk
cbmctrl unlock
</code>

<label id="action-command">
<tag>command <it/device cmdstr/</tag>
Sends <it/cmdstr/ to device <it/device/, secondary address 15 (command/status
channel). Since there is no PetSCII->ASCII conversion, commands must be sent
in <em/upper case/ (kind of poor man's PetSCII conversion). This is because
charset conversion would break the <tt/M-W/ and <tt/M-E/ commands.

Note: If you need PetSCII->ASCII conversion, use <it/pcommand/ instead.

Assuming the device number is 8, this command is identical to (Note: This does
not work on Windows, because <it/echo/ there does not know the <it/-n/ option.)
<code>
cbmctrl lock
cbmctrl listen 8 15
echo -n cmdstr|cbmctrl write -
cbmctrl unlisten
cbmctrl unlock
</code>

<label id="action-pcommand">
<tag>pcommand <it/device cmdstr/</tag>
Like <it/command/, but converts the data from ASCII to PetSCII before sending
it.

<label id="action-dir">
<tag>dir <it/device/</tag>
Read directory from disk in device <it/device/, print on standard out.

<label id="action-download">
<tag>download <it/device address count [file]/</tag>
Read <it/count/ bytes from drive memory, starting at <it/address/ via one
or more <tt/M-R/ commands. Memory contents are written to standard output
if <it/file/ is ommited or equivalent to <tt/"-"/.

<label id="action-upload">
<tag>upload <it/device address [file]/</tag>
Send <it/file/ to drive memory, starting at <it/address/ via one
or more <tt/M-W/ commands. If <it/address/ is -1, the first two bytes from
<it/file/ are considered as start address. Reads standard input if <it/file/ is
ommited or equivalent to <tt/"-"/.

<label id="change">
<tag>change <it/device/</tag>
Wait for a disc to be changed in the specified device. It waits for the current
disc to be removed, for a new disc to be inserted and for the drive door to be
closed. It does not return until the disc is ready to be read or written.
</descrip>

<sect2>cbmctrl Examples<label id="cbmctrl examples">

<p>
Send file contents to printer 4:
<code>
cbmctrl lock
cbmctrl listen 4 0
cbmctrl write file
cbmctrl unlisten
cbmctrl unlock
</code>

<p>
Copy file to disk drive 8:
<code>
cbmctrl lock
cbmctrl open 8 2 FILENAME,P,W
cbmctrl listen 8 2
cbmctrl write file
cbmctrl unlisten
cbmctrl close 8 2
cbmctrl unlock
</code>

<p>
Copy file from disk drive 8:
<code>
cbmctrl lock
cbmctrl open 8 2 FILENAME,P,R
cbmctrl talk 8 2
cbmctrl read file
cbmctrl untalk
cbmctrl close 8 2
cbmctrl unlock
</code>

<p>
Dump 1541 ROM:
<code>
cbmctrl download 8 0xc000 0x4000 > 1541.rom
</code>
or
<code>
cbmctrl download 8 0xc000 0x4000 1541.rom
</code>

<p>
Write file buffer2.bin to drive 9, address 0x500:
<code/cbmctrl upload 9 0x500 buffer2.bin/

<sect1>cbmformat<label id="cbmformat">
<p>
<it/cbmformat/ is a fast low-level disk formatter for the 1541 and compatible
devices (1570, 1571, third-party clones). A 1581 drive is not supported.

The drive routine was taken from the Star Commander ((C) Joe Forster/STA) and
highly improved.

There is also another, very similar tool, <ref id="cbmforng" name="cbmforng">.

<sect2>cbmformat invocation<label id="invoking-cbmformat">
<p>
Synopsis: <tt/cbmformat [OPTION]... DRIVE# NAME,ID/

<it/DRIVE#/ has to be the drive number of the disc drive, <it/NAME/ is a name
with up to 16 characters which will be the name of the disc after formatting,
<it/ID/ is the 2-letter disc ID.

<p>Note: Unlike the <it/N0/ command of the drive, the ID must be given (thus,
no so-called "short format" is possible).

<p>
Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit.

<tag/-V, --version/
Display version information and exit.

<tag/-n, --no-bump/
Do not bump drive head at the beginning. Don't use this on eventually
misaligned drives.

<tag/-x, --extended/
Format a 40 track disk, the BAM format is compatible to SpeedDOS.

<tag/-c, --clear/
clear (demagnetize) this disc.
This is highly recommended if the disc is used for the first time,
or if it was previously formatted for another system (i.e., MS-DOS).
Note that this option takes much time.

<tag/-v, --verify/
verify each track after it is written.
As this needs an extra round of the drive for each track, the formatting time
is almost doubled.

cf. <ref id="note-1571-cbmformat" name="cbmformat Notes for 1571 drives">

<tag/-o, --original/
Fill sectors with the original pattern (0x4b, 0x01, 0x01...) instead of zeroes.
The original pattern is probably due to a bug in the drive ROM, apart from
this, zeroing out unused sectors should give (slightly) better results for
compressed disk images.

cf. <ref id="note-1571-cbmformat" name="cbmformat Notes for 1571 drives">

<tag/-s, --status/
Display drive status after formatting. Normally, <it/cbmformat/ exits after
executing the drive code. With this option turned on, <it/cbmformat/ waits
until the drive has finished formatting and prints the drive status after
initializing the BAM on standard out.

<tag/-p, --progress/
Display a hash mark ('#') for each formatted track. Slows formatting down a 
bit.
</descrip>

<sect2>cbmformat Notes for 1571 drives<label id="note-1571-cbmformat">
<p>
We encountered problems with decent revision/mechanics combinations of the
1571 disk drives when using cbmformat. We highly recommend to use
<it/--original/ and <it/--verify/ with 1571 drives. From our experience, with
<it/--original/, the problem does not occur; with <it/--verify/, the drive
tests each track after it was formatted and ensures that the failure condition
did not occur.

We did not encounter these problems with either of 1541 (1541-II, 1541C), 1570
or 1571CR (the drive which is part of the C128DCR) drives, only with original
1571 drives.

In the current state, cbmformat is not able to format double-sided discs on a
1571 drive.

<sect2>cbmformat Examples<label id="cbmformat examples">

<p>
Format standard disk (35 tracks) in drive 8:
<code>
cbmformat 8 GAMES,42
</code>

<p>
Format standard disk (35 tracks) in drive 9, use (buggy) 1541 sector pattern (for example, because this is a 1571 drive), show drive status when done:
<code>
cbmformat -os 9 1571disc,71
</code>

<p>
SpeedDOS disk (40 tracks), show progress indicator, all sectors zeroed out,
no head banging:
<code>
cbmformat -npx 8 "40 TRACKS,OK"
</code>

<sect1>cbmforng<label id="cbmforng">
<p>
<it>cbmforng</it> is a fast and reliable low-level disk formatter for the
1541 and compatible devices (1570, 1571, third-party clones). It was based
on <ref id="cbmformat" name="cbmformat"> and is designed to become the
designated successor to <ref id="cbmformat" name="cbmformat">, therefore its
name: <it>CBM-Formatter, the Next Generation</it>.

<it/cbmforng/ does not support a 1581 drive.

<p>
Because this is the first official release of <it>cbmforng</it> and because
it was not used in the field by a wider user group, it still contains
additional measurement routines and informational output after the formatting
process was done. When <it>cbmforng</it> prooved its matureness and got back
some features currently missing (progress bar), it will replace
<it>cbmformat</it>.
<p>
To date <it/cbmforng/ should be considered as the more reliable formatter of
both; whenever you should encounter any difficulties with <it>cbmformat</it>,
go for <it/cbmforng/. If you like additional informational messages like e.g.
the RPM value each formatted track was measured, then <it/cbmforng/ is the tool
you want to use. Your feedback helps us to decide, if this additional output
which was needed for developing may find its way into future releases.

<sect2>cbmforng invocation<label id="invoking-cbmforng">
<p>
Synopsis: <tt/cbmforng [OPTION]... DRIVE# NAME,ID/

<it/DRIVE#/ has to be the drive number of the disc drive, <it/NAME/ is a name
with up to 16 characters which will be the name of the disc after formatting,
<it/ID/ is the 2-letter disc ID.

<p>Note: Unlike the <it/N0/ command of the drive, the ID must be given (thus,
no so-called "short format" is possible).

<p>
Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit.

<tag/-V, --version/
Display version information and exit.

<tag/-n, --no-bump/
Do not bump drive head at the beginning. Don't use this on eventually
misaligned drives.

<tag/-r, --retries n/
Set the maximum number of retries on errors. This accounts for all
errors that may happen when formatting all the tracks of the whole disc.

<tag/-x, --extended/
Format a 40 track disk, the BAM format is compatible to SpeedDOS.

<tag/-c, --clear/
clear (demagnetize) this disc.
This is highly recommended if the disc is used for the first time,
or if it was previously formatted for another system (i.e., MS-DOS).
Note that this option takes much time.

<tag/-v, --verify/
verify each track after it is written.
As this needs an extra round of the drive for each track, the formatting time
is almost doubled.

cf. <ref id="note-1571-cbmforng" name="cbmforng Notes for 1571 drives">

<tag/-o, --original/
Fill sectors with the original pattern (0x4b, 0x01, 0x01...) instead of zeroes.
The original pattern is probably due to a bug in the drive ROM, apart from
this, zeroing out unused sectors should give (slightly) better results for
compressed disk images. In comparison to <it>cbmformat</it>, the pattern used
with <it>cbmforng</it> is a little bit more original than the one from its
predecessor. On track one the pattern consists of: 0x00, 0x01, 0x01, ...
instead of the first byte beeing 0x4b. This perfectly reflects the original
1541 ROM format bug.

cf. <ref id="note-1571-cbmforng" name="cbmforng Notes for 1571 drives">

<tag/-s, --status/
In addition to the informational output of internal values from the formatting
process, the drive status is displayed.
<!--
Womo: As long as the additional informational output is given after
      formatting, cbmforng does not exit in either case. Therefore
      the following note does not apply yet.

Display drive status after formatting. Normally, <it/cbmforng/ exits
after executing the drive code. With this option turned on, <it/cbmforng/
waits until the drive has finished formatting and prints the drive status
after initializing the BAM on standard out.
-->
</descrip>

<sect2>cbmforng Notes for 1571 drives<label id="note-1571-cbmforng">
<p>
We encountered rare failure conditions with decent revision/mechanics
combinations of the 1571 disk drives when using cbmforng. We highly
recommend to use <it/--original/ and <it/--verify/ with 1571 drives. From
our experience, with <it/--original/, the problem does not occur. With
<it/--verify/, the drive tests each track after it was formatted and ensures
that the failure condition did not occur; otherwise the same track is formatted
again, as often as the currently set retry value allows.

We did not encounter these problems with either of 1541 (1541-II, 1541C), 1570
or 1571CR (the drive which is part of the C128DCR) drives, only with original
1571 drives.

In the current state, cbmforng is not able to format double-sided discs on a
1571 drive.

<sect2>cbmforng Examples<label id="cbmforng examples">

<p>
Format standard disk (35 tracks) in drive 8:
<code>
cbmforng 8 GAMES,42
</code>

<p>
Format standard disk (35 tracks) in drive 9, use (buggy) 1541 sector pattern
(for example, because this is a 1571 drive), show drive status when done:
<code>
cbmforng -os 9 1571disc,71
</code>

<p>
SpeedDOS disk (40 tracks), verify formatted tracks, all sectors zeroed out,
no head banging:
<code>
cbmforng -nvx 8 "40 TRACKS,OK"
</code>


<sect1>d64copy<label id="d64copy">
<p>
<it/d64copy/ is a fast disk image transfer (both read and write) program for
the 1541 and compatible devices (1570, 1571, third-party clones). A 1581 drive
is <it/not/ supported! Maximum transfer speed is achieved by custom drive- and
transfer-routines based on the Star Commander ((C) Joe Forster/STA) routines.

<sect2>d64copy invocation<label id="invoking-d64copy">
<p>
Synopsis: <tt/d64copy [OPTION]... SOURCE TARGET/

<p>
Either SOURCE or TARGET must be an external drive, valid names are 8, 9, 10 and
11. The other parameter specifies the file name of the .d64 image.

Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit

<tag/-V, --version/
Display version information and exit.

<tag/-q, --quiet/
Quiet output, fewer messages (also suppresses warnings, should not be used)

<tag/-v, --verbose/
Verbose output, more messages (can be repeated)

<tag/-n, --no-progress/
Omit progress display

<tag>-s, --start-track=<it/start track/</tag>
Set start track (defaults to 1)

<tag>-e, --end-track=<it/end track/</tag>
Set end track (default is 35 for .d64 images, 70 for .d71 images). <it/d64copy/
is able to access tracks 1-35 in <tt/original/ transfer mode and 1-42 with
<tt/serial1/, <tt/serial2/ and <tt/parallel/. The 1571 supports tracks 1-70
in double sided (.d71) mode.

<tag>-t, --transfer=<it/transfer mode/</tag>
Set transfermode. Valid modes are:
<itemize>
<item><tt/auto/     (default)
<item><tt/original/ (slowest)
<item><tt/serial1/
<item><tt/serial2/
<item><tt/parallel/ (fastest)
</itemize>
<tt/original/ and <tt/serial1/ should work in any case.
<tt/serial2/ won't work with more than one device
connected to the IEC bus, 
<tt/parallel/ requires an additional XP1541/XP1571 cable.

<p>
If <tt/auto/ is used, d64copy itself determines the best transfer mode usable
with the current setup, and uses that one. Thus, you will seldom want to 
manually overdrive the <it>transfer mode</it> option.

<tag>-i, --interleave=<it/interleave/</tag>
Set interleave value. This is ignored when reading in warp mode. Default is 16
for transfer mode <tt/original/, for turbo and warp write as follows:
<tscreen><verb>

          turbo (r/w)    warp (write only)
serial1       3                 5
serial2      12                11
parallel      6                 3

</verb></tscreen>
Lower values might slightly reduce transfer times, but if set a bit to low,
transfer times will dramatically increase.

<tag>-w, --warp</tag>
Enable warp mode. This is default now; this option is only supported for
backward-compatibility with OpenCBM (cbm4linux/cbm4win) versions before 0.4.0.

<tag>--no-warp</tag>
Disable warp mode. Warp mode is usually a good idea for transferring disk
images unless you have a very slow CPU and/or bad disk material. Warp mode
sends raw GCR data over the bus, which assures data integrity on the PC side
and relieves the drive's CPU. Thus, it is unlikely you will want to use that
option.

<tag>-b, --bam-only</tag>
BAM-only copy. Only blocks marked as allocated are copied. For extended tracks
(36-40), SpeedDOS BAM format is assumed. Use with caution, at least one wide-spread
directory editor tends to forget to allocate some directory blocks.

<tag>-B, --bam-save</tag>
Safe BAM-only copy. This is like the <tt/-b/ option but always copies the
entire directory track (18, 18 and 53 in double-sided mode).

<tag>-d, --drive-type=<tt/type/</tag>
Skip drive type detection. <tt/0/ or <tt/1541/ specifies 1541 mode (1 MHz,
parallel cable at VIA $1800), <tt/1/ or <tt/1571/ forces 1571 mode (2 MHz,
parallel cable at CIA $4000).

<tag>-2, --two-sided</tag>
Double-sided mode for copying .d71 images to/from a 1571 drive. Warp mode is
not supported (yet).

<tag>-r, --retry-count=<tt/count/</tag>
Number of retries.

<tag>-E, --error-mode=<tt/mode/</tag>
Controls whether error is appended to the disk image (15x1->PC only).
Allowed values for <tt/mode/ are (abbreviations allowed):
<itemize>
<item><tt/always/
<item><tt/on_error/  (default)
<item><tt/never/
</itemize>

</descrip>

<sect2>d64copy Examples<label id="d64copy examples">

<p>
Read a D64 disc image from the floppy in drive 8 to the file image.d64,
automatically selecting the fastest transfer method:
<code>
d64copy 8 image.d64
</code>

<p>
Copy the D64 disc image in image.d64 to the floppy in drive 9, automatically
selecting the fastest transfer method:
<code>
d64copy image.d64 9
</code>

<p>
Copy a double-sided disc from a 1571 drive 9 to image.d71, using
<tt/serial1/ transfer method and only reading the blocks which are
marked as used in the BAM:
<code>
d64copy -2 -B --transfer=serial1 9 image.d64
</code>

<sect1>cbmcopy<label id="cbmcopy">
<p>
<it/cbmcopy/ is a fast file transfer program for various disk drives,
in particular the 1541, 1570, 1571 and 1581 devices.
Maximum transfer speed is achieved by custom drive- and transfer-routines based
on the Star Commander ((C) Joe Forster/STA) routines.

<sect2>cbmcopy invocation<label id="invoking-cbmcopy">
<p>
Synopsis: <tt/cbmcopy [OPTION]... DEVICE# FILE.../

<p>
DEVICE# specifies the drive number for file copy.
The remaining arguments specify the files to be sent to/read from the disk
drive. This version supports 
Raw, PC64 (P00) and T64 files. They are recognized when sending files to the
disk drive, files read from external devices are always stored as raw binary
data.

Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit

<tag/-V, --version/
Display version information and exit.

<tag/-q, --quiet/
Quiet output, fewer messages (also suppresses warnings, should not be used)

<tag/-v, --verbose/
Verbose output, more messages (can be repeated)

<tag/-n, --no-progress/
Omit progress display

<tag/-r, --read/
Operate in read-mode, i.e. read data from an external device.
Starting <it/cbmcopy/ as <it/cbmread/ has the same effect.

<tag/-w, --write/
Operate in write-mode, i.e. send files to an external device.
Starting <it/cbmcopy/ as <it/cbmwrite/ has the same effect.

<tag>-t, --transfer=<it/transfer mode/</tag>
Set transfermode. Valid modes are:
<itemize>
<item><tt/auto/    (default)
<item><tt/serial1/  (slowest)
<item><tt/serial2/
<item><tt/parallel/ (fastest, not possible with a 1581)
</itemize>
<tt/serial1/ should work in any case.
<tt/serial2/ won't work with more than one device
connected to the IEC bus, 
<tt/parallel/ requires a XP1541/XP1571 cable in addition to the XM/XA1541.
If <tt/auto/ is given, or this option is completely omitted, cbmcopy
will automatically determine the fastest transfer method possible with the
current setup. Thus, you will seldom want to  manually overdrive the
<it>transfer mode</it> option.

<tag>-d, --drive-type=<tt/type/</tag>
Skip drive type detection.
Valid types are <tt/1541/, <tt/1570/, <tt/1571/ and <tt/1581/.

<tag>-o, --output=<tt/name/</tag>
Specifies target name. ASCII/PetSCII conversion is performed when in write-mode.

<tag>-a, --address=<tt/address/</tag>
Overrides the file's first two bytes with <it/address/.

<tag/-R, --raw/
Skip file type detection. File data is sent as is.
This option is only valid in write-mode.

<tag>-f, --file-type=<tt/type/</tag>
Specifies/overrides file type. Supported types are <tt/P/, <tt/S/, <tt/D/,
<tt/U/.
Raw files default to <tt/P/, whereas the T64 format contains meta data
which includes the file type. For PC64 files, <it/cbmwrite/ tries to guess
the file type from the file extension.
This option is only valid in write-mode.

</descrip>

<sect2>cbmcopy Examples<label id="cbmcopy examples">

<p>
Read a file called <it/cbmfile/ from drive 8 and store its binary value into
the file file.bin, automatically selecting the fastest transfer method:
<code>
cbmcopy -r 8 cbmfile -o file.bin
</code>

<p>
Write out the file file.p00 in P64 format to the disc in drive 9, using
<tt/serial1/ transfer method:
<code>
cbmcopy -w 9 file.p00
</code>

<sect1>rpm1541<label id="rpm1541">
<p>
<it/rpm1541/ is a demo program. It finds out the rotation speed (in rounds per
minute, rpm) of the drive motor.
<it/rpm1541/ supports a 1541, 1570 or 1571 drive.
A 1581 drive is <it/not/ supported.

For Linux, <it/rpm1541/ is not installed automatically. You have to compile it
yourself (found in <tt>demo/rpm1541/</tt>) if you want to use it.
For Windows, it is part of the binary distribution.

<sect2>rpm1541 usage<label id="rpm1541-usage">
<p>
Synopsis: <tt>rpm1541 <it>[device]</it></tt>
<p>
The optional parameter <it>device</it> is the device number of the drive which
should be tested. If not specified, <tt/rpm1541/ utilizes drive 8.

<sect2>rpm1541 Example<label id="rpm1541-example">
<p>

Find out the rotation speed of drive 11:
<code>
cbmctrl lock
rpm1541 11
cbmctrl unlock
</code>

<sect1>flash<label id="flash">
<p>
<it/flash/ is a demo program. It flashes the drive LED.
<it/flash/ works with 1541, 1570 or 1571 drives. A 1581 drive is <it/not/ supported.

For Linux, <it/flash/ is not installed automatically. You have to
compile it yourself (found in <tt>demo/flash/</tt>) if you want to use it.
For Windows, it is part of the binary distribution.

<sect2>flash usage<label id="flash-usage">
<p>
Synopsis: <tt>flash <it>[device]</it></tt>
<p>
The optional parameter <it>device</it> is the device number of the drive which
should flash its LED. If not specified, <tt/flash/ utilizes drive 8.

<sect2>flash Example<label id="flash-example">
<p>

Let the drive LED flash on drive 10:
<code>
cbmctrl lock
flash 10
cbmctrl unlock
</code>

<sect1>morse<label id="morse">
<p>
<it/morse/ is a demo program. It uses the drive LED to output a text in morse code.
<it/morse/ works with 1541, 1570 or 1571 drives. A 1581 drive is <it/not/ supported.

For Linux, <it/morse/ is not installed automatically. You have to compile it
yourself (found in <tt>demo/morse/</tt>) if you want to use it.
For Windows, it is part of the binary distribution.

<sect2>morse usage<label id="morse-usage">
<p>
Synopsis: <tt>morse <it>[device]</it></tt>
<p>
The optional parameter <it>device</it> is the device number of the drive which
should flash its LED. If not specified, <tt/morse/ utilizes drive 8.

<sect2>morse Examples<label id="morse-examples">
<p>

Morse the text "SOS", "HELLO" and "YOU" (in this order) on drive 9.
<code>
cbmctrl lock
morse 9
cbmctrl command 9 U3:HELLO
cbmctrl command 9 U3:YOU
cbmctrl unlock
</code>


<sect>OpenCBM API<label id="opencbm-API">
<p>
All communication between the user space applications and the kernel module
is done with ioctl's. Since ioctl's are quite unportable and hardly provide
any type-safety, there are a number of wrapper-functions along with a couple
of convenience functions implemented in <tt/libopencbm.a/ (Linux) or
<tt/opencbm.dll/ (Windows). The prototypes can be found in the header file
<tt/opencbm.h/.

<sect1>Preprocessor macros<label id="opencbm-preproc">
<p>

<itemize>
<item>#define IEC_DATA 0x01</item>
<item>#define IEC_CLOCK 0x02</item>
<item>#define IEC_ATN 0x04</item>
</itemize>

These defines are used by the <it/cbm_iec_*()/ functions. You will definitely
need this if you intend to implement your own custom transfer routines. See
the <tt/libd64copy//<tt/libcbmcopy/ source for more information.

<sect1>Enumeration types<label id="opencbm-enum-types">
<p>

<itemize>
<item>enum cbm_device_type_e
<itemize>
<item/cbm_dt_unknown/
<item/cbm_dt_1541/
<item/cbm_dt_1570/
<item/cbm_dt_1571/
<item/cbm_dt_1581/
</itemize>
</itemize>

<p>
<itemize>
<item>enum cbm_cable_type_e
<itemize>
<item/cbm_ct_unknown/
<item/cbm_ct_none/
<item/cbm_ct_xp1541/
</itemize>
</itemize>

<sect1>Generic types<label id="opencbm-types">

<p>
<itemize>
<item>CBM_FILE</item>
</itemize>

This type is used to take a handle to the CBM driver. Only use this type, as it
hides the differences between Windows and Linux.

An invalid CBM_FILE has value CBM_FILE_INVALID.

<sect1>Functions<label id="opencbm-functions">
<p>

(All functions except <tt/cbm_driver_open():/ <it/f/ must be a valid file
descriptor)

<sect2>Basic I/O<label id="opencbm-basic-functions">

<p><descrip>
<tag/int cbm_driver_open(CBM_FILE *f, int port);/
Opens the driver. <tt/port/ isn't used by now and should be 0.
After successful completion, 0 is returned along with a valid CBM_FILE
descriptor in <tt/f/.

<tag/void cbm_driver_close(CBM_FILE f);/
Closes the driver.

<tag/void cbm_lock(CBM_FILE f);/
The equivalent to <it/cbmctrl lock/. Make sure the parallel port is
kept locked even if the driver is closed with cbm_driver_close().

<tag/void cbm_unlock(CBM_FILE f);/
The equivalent to <it/cbmctrl unlock/. Unlock the parallel port as soon is the
driver is closed with cbm_driver_close().

<tag/int cbm_raw_read(CBM_FILE f, void *buf, size_t size);/
Retrieve data after <tt/cbm_talk();/. At most <tt/size/ bytes are read.
Return value is the actual number of bytes read. &lt; indicates an error.

<tag/int cbm_raw_write(CBM_FILE f, const void *buf, size_t size);/
Send data after <tt/cbm_listen();/. At most <tt/size/ bytes are written,
Return value is the actual number of bytes written. &lt; indicates an error.

<tag/int cbm_listen(CBM_FILE f, __u_char dev, __u_char secadr);/
Tell device <it/dev/ to listen on secondary channel <it/secadr/.
Return value is 0 on success, &lt; 0 means error.

<tag/int cbm_talk(CBM_FILE f, __u_char dev, __u_char secadr);/
Tell device <it/dev/ to talk on secondary channel <it/secadr/.
Return value is 0 on success, &lt; 0 means error.

<tag/int cbm_open(CBM_FILE f, __u_char dev, __u_char secadr);/
Prepare device <it/dev/ for opening a file. This device listens for the file
name after this call which is normally sent by a call to the
<it/write()/-function followed by an <it/unlisten()/ call.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_close(CBM_FILE f, __u_char dev, __u_char secadr);/
Close file associated with secondary address <it/secadr/ on device <it/dev/.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_unlisten(CBM_FILE f);/
Send unlisten on bus.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_untalk(CBM_FILE f);/
Send untalk on bus.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_get_eoi(CBM_FILE f);/
Get EOI flag after bus read, return value is 0 with no EOI, otherwise 1.
When EOI is set to 1, the active talker has nothing more to send.

<tag/int cbm_clear_eoi(CBM_FILE f);/
Reset EOI flag.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_reset(CBM_FILE f);/
Do a hardware reset on all connected devices. Control is returned after
a 5 second delay.
</descrip>

<sect2>Low-level port access<label id="opencbm-lowlevel-functions">

<p><descrip>
<tag/__u_char cbm_pp_read(CBM_FILE f);/
Read byte from XP1541/XP1571 bus. No handshaking or such involved.

<tag/void cbm_pp_write(CBM_FILE f, __u_char c);/
Write byte to XP1541/XP1571 bus. No handshaking or such involved.

<tag/int cbm_iec_poll(CBM_FILE f);/
Read status of all bus lines. Return value is a combination of 
<tt/IEC_ATN/, <tt/IEC_CLOCK/ and <tt/IEC_DATA/.

<tag/int cbm_iec_get(CBM_FILE f, int line);/
Get (logical) status of line <it/line/.

<tag/void cbm_iec_set(CBM_FILE f, int line);/
Activate lines <it/line/ (set to 0V).
<it/line/ can be one of or a combination with OR of any of IEC_DATA, IEC_CLOCK,
IEC_ATN.

<tag/void cbm_iec_release(CBM_FILE f, int line);/
Release lines <it/line/ (set to 5V).
<it/line/ can be one of or a combination with OR of any of IEC_DATA, IEC_CLOCK,
IEC_ATN.


<tag/void cbm_iec_setrelease(CBM_FILE f, int setline, int resetline);/
Set lines <it/setline/ (set to 0V) and release line <it/releaseline/ (set to
5V)
<it/setline/ and <it/resetline/ can each be one of or a combination with OR of
any of IEC_DATA, IEC_CLOCK, IEC_ATN. If a line is part of both <it/setline/ and
<it/resetline/, the outcome is undefined.


<tag/int cbm_iec_wait(CBM_FILE f, int line, int state);/
Experimental, do not use.
</descrip>

<sect2>Helper functions<label id="opencbm-helper-functions">

<p><descrip>
<tag/int cbm_upload(CBM_FILE f, __u_char dev, int adr, void *prog, int size);/
Write <it/prog/ into device <it/dev/'s memory space via a series of <tt/"M-W"/
commands.

<tag/int cbm_device_status(CBM_FILE f, __u_char drv, void *buf, int bufsize);/
Read device status info <it/buf/, at most <it/bufsize/ bytes are read.
Returns <it/atoi(buf)/.

<tag/int cbm_exec_command(CBM_FILE f, __u_char drv, void *cmd, int len);/
Execute command <it/cmd/. Returns number of bytes actually written.
if <it/len/ is 0, <it/cmd/ is considered a 0-terminated string.

<tag/int cbm_identify(CBM_FILE f, __u_char drv, enum cbm_device_type_e *t, const char **type_str);/
Tries to identify the device <it/drv/. The hardware type is returned in <it/t/,
<it/type_str/ contains a descriptive string which also includes the drives'
operating system. Both <it/t/ and <it/type_str/ may be <tt/NULL/ in case the
caller is not interrested in any of both values.<p>
The return value is <tt/0/ if the device responded to the <tt/"M-R"/ command,
even if it could not be identified, &lt; 0 indicates error.

<tag/int cbm_identify_xp1541(CBM_FILE f, __u_char drv, enum cbm_device_type_e *t1, enum cbm_cable_type_e *t2);/
Tries to identify the device <it/drv/. The hardware type is returned in <it/t1/,
<it/t2/ contains whether the drive has an parallel (XP1541) cable attached.
Both <it/t1/ and <it/t2/ may be <tt/NULL/ in case the caller is not interrested
in any of both values.<p>
The return value is <tt/0/ if the device responded to the <tt/"M-R"/ command,
even if it could not be identified, &lt; 0 indicates error.

</descrip>

<sect2>PetSCII functions<label id="opencbm-petscii-functions">

<p><descrip>
<tag/char cbm_petscii2ascii_c(char character);/
Converts one character <it/character/ from PetSCII to ASCII.

<tag/char cbm_ascii2petscii_c(char character);/
Converts one character <it/character/ from ASCII to PetSCII.

<tag/char * cbm_petscii2ascii(char *str);/
Convert a null-terminated string <it/str/ from PetSCII to ASCII.

<tag/char * cbm_ascii2petscii(char *str);/
Convert a null-terminated string <it/str/ from ASCII to PetSCII.

</descrip>

<sect2>Parallel Burst functions<label id="opencbm-parburst-functions">

<p><descrip>
<tag/__u_char cbm_parallel_burst_read(CBM_FILE f);/
Support function for mnib. Do not use.

<tag/void cbm_parallel_burst_write(CBM_FILE f, __u_char c);/
Support function for mnib. Do not use.

<tag/int cbm_parallel_burst_read_track(CBM_FILE f, __u_char *buffer, unsigned int length);/
Support function for mnib. Do not use.

<tag/int cbm_parallel_burst_write_track(CBM_FILE f, __u_char *buffer, unsigned int length);/
Support function for mnib. Do not use.

</descrip>

<sect2>libd64copy <it/TODO/<label id="opencbm-libd64copy-functions">
<p>
Not documented yet. See <it/libd64copy/ and <it/d64copy/ source.<p>
Types and prototypes are defined in <tt/d64copy.h/.

<sect2>libcbmcopy <it/TODO/<label id="opencbm-libcbmcopy-functions">
<p>
Not documented yet. See <it/libcbmcopy/ and <it/cbmcopy/ source.<p>
Types and prototypes are defined in <tt/cbmcopy.h/.


<sect>Known bugs and problems<label id="knownbugs">
<p>
There are some known problems in OpenCBM:

<itemize>
<item><it/cbmcopy/ is still known to have some protocol races, especially with
 1581 drives; thus, it does not always work reliably.
<item><it/cbmctrl detect/ as well as <it/cbmcopy/ and <it/d64copy/ do not
 recognize the drive type if some custom ROM is used.
<item>Windows: If you have any other devices connected to your parallel port,
 you cannot use them as long as cbm4win is installed. In this case, either
 remove OpenCBM whenever you want to access that other device, or install
 OpenCBM with <it/instcbm --lock=no/ and make sure to issue <it/cbmctrl lock/
 before accessing the drive, and <it/cbmctrl unlock/ afterwards.
<item>Windows: Third party PCI parallel port cards are problematic.
  In fact, I tried several, but none of them did work with
  OpenCBM on Windows currently. Anyway, I have had at least one positive
  report that this is possible.
  It seems the drivers for such parallel port cards do not specifically
  allow the interrupt to be routed to the PC, as most parallel devices
  nowadays do not need the interrupt. Unfortunately, this is not true
  for OpenCBM, which actually needs it!
</itemize>

<sect>Misc

<sect1>Credits

<p>
The fast format drive routine used by `cbmformat' and the turbo and warp drive
routines used in `libd64copy' and `libcbmcopy' are heavily based on Joe
Forster/STAs Star Commander routines.

The XP1541 and XP1571 cables (C) by Joe Forster/STA.
The original XE1541 cable (C) by Nicolas Welte and Wolfgang Moser
The XA1541 cable (C) by Michael Klein and Nicolas Welte

<sect1>Contributions

<p>
People who directly or indirectly contributed to OpenCBM (in no particular
order):

<itemize>
<item>
<it/Michael Klein/ started the original cbm4linux work (which was a very big
part)
<item>
<it>Joe Forster/STA</it> made the Star Commander and supplied the source and
about the X?1541 interfaces; who knows, without this work, OpenCBM might never
have appeared at all.
<item>
<it/Nicolas Welte/ helped with the XA1541 and XM1541 interfaces and supplied a
free factory-new 1571 mechanic for Michael
<item>
<it/Andreas Boose & the VICE team/ made VICE
<item>
<it/André Fachat/ made the xa 6502 crossassembler
<item>
<it/Ullrich von Bassewitz/ made the ca65 crossassembler
<item>
<it/Wolfgang Moser/ contributed <it/many/ discussions, patches, and hardware
whenever it was needed.
<item>
<it/Spiro Trikaliotis/ with discussions, lots of fixes and doing an overall
great review while porting the driver to "other" operating systems ;-)
<item>
<it/Andreas Senk/ reported a problem with <htmlurl
 url="http://home.arcor.de/jochen.adler/ajnhome.htm" name="IEC2IEEE"> and donated
 an IEC2IEEE device. This led to the discovery of a severe protocol bug in the
 implementation of OpenCBM.
<item>
<it/Jochen Alder/, author of <htmlurl
 url="http://home.arcor.de/jochen.adler/ajnhome.htm" name="IEC2IEEE">, helped
 in debugging the problem Andreas Senk reported (cf. above).
<item>
<it/Till Harbaum/ found some bugs while working on the
<htmlurl url="http://www.harbaum.org/till/xu1541/index.shtml" name="XU1541">
<item>
<it/Frédéric Brière/ prepared a Debian package of OpenCBM. While he was doing
this, he discovered some problems and fixed them.
</itemize>

<p>
And anyone else who sent patches, suggestions, praises & flames!

<sect1>Feedback

<p>
Feel free to drop a note if you have ideas, patches etc. or if you just want to
tell how happy you are with this program ;-)

<p>
If possible, we would prefer if you send bug reports, patches and wishlist
itemts to the <htmlurl url="http://sf.net/" name="SourceForge"> tracker on
<htmlurl url="http://sourceforge.net/tracker/?group_id=122047"
name="http://sourceforge.net/tracker/?group_id=122047">, and general
discussions on the SourceForge mailing list `opencbm-user' on <htmlurl
url="http://sourceforge.net/mail/?group_id=122047"
name="http://sourceforge.net/mail/?group_id=122047">.

Have fun,

The OpenCBM team.

</article>
